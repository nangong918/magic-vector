**操作系统**
====

# 进程与线程
## 进程

## 线程

线程调度，线程状态

### 线程的生命周期
* 新建状态 (New)
  新建了线程，但是未启动。
  状态转变: 当调用 `start()` 方法时，线程从新建状态转变为就绪状态
* 就绪状态 (Runnable)
  线程处于就绪状态时，表示它已经准备好执行，但此时可能由于操作系统的线程调度策略而尚未分配 CPU 时间。等待os调度.
  状态转变: 一旦 CPU 资源可用，线程将从就绪状态转移到运行状态。 如果优先级更高的线程进入就绪状态，该线程可能被暂时挂起。
* 运行状态 (Running)
  线程处于运行状态时，表示它正在执行代码。此状态下线程正在消耗 CPU 资源。
  状态转变: 线程可以通过调用 `yield()` 或 `sleep()` 方法主动让出 CPU，或因资源等待等而进入阻塞状态
* 阻塞状态 (Blocked)
  当线程试图获取对象的锁（例如，通过 `synchronized` 关键字）而该锁已被其他线程持有时，线程进入阻塞状态。
  状态转变: 一旦锁释放，线程将转回就绪状态。 此时，该线程无法继续执行直到能够获取到锁。
* 等待状态 (Waiting)
  线程处于等待状态时，表示它在等待其他线程的通知或特定条件的满足。此状态可以通过调用 `Object.wait()`、`Thread.join()` 或 `LockSupport.park() `等方法进入。
  状态转变: 当被其他线程以 `notify()`、`notifyAll()` 或相关方法唤醒时，线程将转回就绪状态。
* 超时等待状态 (Timed Waiting)
  类似于等待状态，但线程在超时时间内将自动返回到就绪状态，避免无限期等待。可以通过 Thread.sleep(millis) 或 Object.wait(timeout) 等方法进入。
  状态转变: 当超时或被其他线程唤醒，线程将转回就绪状态
* 死亡状态
  描述: 当线程执行完成或因异常终止时，线程进入终止状态。在此状态下，线程资源已经被释放，线程生命周期结束。
  状态转变: 无法再返回其他状态

### 线程代码实现

Thread
JVM线程池
Java nio
Netty nio
WebFlux
RxJava
Kotlin协程

### 线程锁

# 文件与设备
oss

