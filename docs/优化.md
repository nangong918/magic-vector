**优化 记录**
====

## 待优化
todo: 不要简单任务复杂话, 虽然说流式LLM + TTS能节省很多性能, 但是问题在于引入大量的变量来控制状态. 
其中很大的问题是: 是否是FunctionCall由AI判断, 而这一点决定整个系统如何结束.如果AI判断错了. 整个系统无法结束, 就卡死了

最少代码量原则, 不要把简单问题复杂化.

qwen3-plus蠢笨如牛, 增加拦截器看看到底传递了什么, 使用deepseek官方的r1模型

进行混淆 + 反编译检查；进行数据抓包检查

虽然RealtimeChatService在按照设计模式标准重构后优化了一些, 但是仍然存在状态不明确, 状态传递混乱的问题. 要重新设计, 将状态集成在Context种而不是Service的逻辑的临时变量中(这样导致了严重的耦合和不可控)

当前AI在调用还是不调用MCP有点笨, 可以考虑在传入部分参数指挥是否调用MCP

搜索学习判断SpringBoot、Android性能的方法，根据性能分析对项目进行性能分析。

(待优化A1)长时间未连接之后再次连接会发生Connect Reset目前采用的是递归的方式重试，可能造成堆栈溢出。考虑改为循环调用的方式

Agent的设定改变: 新增Agent详情页面, 可以编辑Agent的设定

YOLOv8实现视频流目标活动检测调参 + 物品阈值增加，person阈值下降 + YOLOv8物品优先级List + 眼睛移动配合YOLOv8优先级List

视觉理解模型：图片输入要经过压缩

研究Java设计模式, 好好的锤炼代码

解决Test代码占用正式性能的问题, Spring通过配置参数进行懒加载

Android 使用DiffUtil优化Adapter性能
Android 的websocket也需要消息队列，避免写入IO异常

当前的agent提示词参数是通过每次提交实现，后续需要改为专门的提示词function call，在调用mcp之前先去调用获取提示词方法

Http上传视觉的线程Future要能取消

Android使用Service和kotlin协程优化后台数据处理、网络请求的性能

学习计算机网络相关，优化websocket长连接，心跳请求等

FormData传递的时候MediaType出错 (http文件传输不熟悉)

输入token太严重了，寻求解决方案: 1. github的方法，2. Agent拦截器，3.对话上下文：8 -> 4

各种多线程，异步，线程中断问题

visionTool的超时时机，现在是写死的30秒，应该改为Http超时为5s，如果连接成功http，visionModel的超时事件为25s，一共30s

### 待优化任务
1. 面向对象, Java设计模式(13种设计模式), Android设计模式(Mvp, Mvc, Mvvm), UML -> 改造列出带改造的代码, 并执行改造; 面向过程: 开发嵌入式追求极致性能的时候; 应用生命周期管理
2. 数据结构: Android, Spring各种数据结构设计合理化; 最快的数据结构设计: Java数据结构, Cpp的STL数据结构
3. 耗时任务与异步: 线程, 线程池, 协程, 线程安全, 线程锁, RxJava, WebFlux, 线程订阅与取消, Android的IO线程与Work线程
4. 网络: Http, WebSocket, WebRTC, TCP/IP, MQTT, UDP, SSE, 丢包与校验, 大批量传输, FormData, MediaType, 网络七层; 网关, 代理\反向代理
5. IO: 文件存储与资源管理, 文件压缩, 幂等, minio反向代理
6. 数据传递: EventBus, SpringEvent, 性能分析, 内存开销, 消息解耦
7. 性能分析: SpringBoot, Android性能分析工具; Spring调用链路, JVM调参, Android监听ANR; 内存，动态运行性能，内存泄漏分析; Spring内存分析，JSON等数据结构化反射性能开销。图片压缩，流传递。
8. 多级缓存: SpringBoot网络请求缓存, Android本地缓存
9. 算法: SpringBoot搜索算法(数据库快速检索, 聊天记录快速查询, 搜索算法), Android排序算法(多数据源插入排序测试)
10. 数据库: 数据库选型, 表设计, SQL优化, 分库分表, 缓存, E-R图
11. (*)计算机组成原理 -> RK3588 Linux开发
12. 语言复习：Java，Cpp
13. 框架复习：Android(应用层，JNI，HAL，Linux)，树莓派(RK3588)，Spring（非微服务，分布式，那部分理解就好）


## 待解决

第一次chat的数据会继续交给了第二个chat agent中，两次数据流会合并到一起存储

需要设计当前是否处于对话状态，属于对话状态的话不能再次发送起始符，并且如果有vision任务不能发送结束符。

第一句和前面的TTS并没有成功播放


视觉Agent调用tts异常：可能是因为vision调用的时候取消了tts任务

AI模型调用都有HttpClient超时;出现了说话然后语音识别不出来的bug

Android 消息二分插入排序存在问题

无论我说什么Agent总是会调用MCP接口




## 已解决

tts线程休眠异常：
```text
java.lang.InterruptedException: sleep interrupted
InterruptedException 就是因为在尝试对一个已经取消的 Future 执行休眠操作:
提交了一个 generateAudio 任务到线程池，返回 ttsFuture
如果这个任务还在休眠时，调用了 ttsFuture.cancel(true)
cancel(true) 会中断正在执行的线程，导致 Thread.sleep() 抛出 InterruptedException
可以直接不管这个报错: InterruptedException 是正常的：这是预期的行为，不是错误
```

websocket并发发送消息问题：
```text
java.lang.IllegalStateException: The remote endpoint was in state [TEXT_PARTIAL_WRITING] which is an invalid state for called method
WebSocket 并发写入 导致的。在多线程环境下，多个 Flux 片段同时调用 sendMessage()，导致 WebSocket 端点状态混乱
解决方案：Java内部消息队列
```
```java
// 消息队列，将高并发的消息缓存
private final BlockingQueue<MessageTask> messageQueue = new LinkedBlockingQueue<>();
// 标志符
private final AtomicBoolean isProcessing = new AtomicBoolean(false);
// 线程池
private final ThreadPoolTaskExecutor messageExecutor;
// 解决：java.lang.IllegalStateException
synchronized (session) {
    session.sendMessage(new TextMessage(task.message));
}
```

传递图片流存在问题: 图片的base64流过大, 导致websocket断开:
```text
[websocket] 连接断开：id=a780c38c-abd2-d111-6b61-0226a2d03498，reason=CloseStatus[code=1009, reason=The decoded text message was too big for the output buffer and the endpoint does not support partial messages]
```
解决方案: 暂时使用Http传输照片, 如果需要实时传递图片可以考虑使用UDP/WebRTC/RTP/RTCP/RTMP
todo1: 好好学习网络协议,ws;tcp,udp,rtmp等。实现使用udp/WebRTC/RTMP实现视频通话
todo2: 学习计算机组成原理, 学习分段字节流和循环冗余校验, 实现不用Base64传递数据, 而是直接使用拆分的字节流.

语音的延迟调用: 1.语音真实效果, 2.批量转换 3. 触发API请求频繁

SpringAlibaba AI长时间不说话会连接超时, 需要检查WebSocket Client解决超时问题: （Bug仍然存在，只是添加了flux重试机制）
```text
2025-10-23T21:52:34.938+08:00 ERROR 30184 --- [open-api] [ctor-http-nio-3] o.s.ai.chat.model.MessageAggregator      : Aggregation Error

org.springframework.web.reactive.function.client.WebClientRequestException: Connection reset
	at org.springframework.web.reactive.function.client.ExchangeFunctions$DefaultExchangeFunction.lambda$wrapException$9(ExchangeFunctions.java:137) ~[spring-webflux-6.2.0.jar:6.2.0]
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ Request to POST https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation [DefaultWebClient]
Original Stack Trace:
Caused by: java.net.SocketException: Connection reset
```

Android端异常断开, Spring端会抛出异常: (本质上是无害影响，但是还是要注意回收资源)
```text
java.io.EOFException: null
```

Android 在退出CameraX预览之后出现崩溃:
```text
[SurfaceView[com.magicvector/com.magicvector.activity.test.AgentEmojiTestActivity]#5(BLAST Consumer)5](id:2eed00000009,api:4,p:2371,c:12013) queueBuffer: BufferQueue has been abandoned
```

解决方案: 因为SurfaceView可能在onStop之前销毁, 所以需要在onPause中停止分析(从被抛弃的Buffer中继续获取数据)
```kotlin
    // 由于surface可能在onStop销毁，所以分析器要在onPause中提前结束
    private val cameraLock = Any()
    override fun onPause() {
        super.onPause()
        // 线程同步，避免在Surface销毁的时候还从Buffer中获取数据
        synchronized(cameraLock){
            // 停止线程池行为
            cameraExecutor.shutdownNow()
            // 停止分析器
            imageAnalyzer?.clearAnalyzer()
            // 停止相机
            cameraProvider?.unbindAll()
        }
    }
```

function call注入异常：
```java
        Flux<String> responseFlux = chatClient.prompt()
                .user(sentence)
                // 添加工具Function Call; MCP
                .tools(visionToolService)
                .stream()
                .content()
                // 3500ms未响应则判定超时，进行重连尝试
                .timeout(Duration.ofMillis(ModelConstant.LLM_CONNECT_TIMEOUT_MILLIS));
```
```text
java.lang.NoClassDefFoundError: com/github/victools/jsonschema/generator/AnnotationHelper
at com.github.victools.jsonschema.module.jackson.JsonUnwrappedDefinitionProvider.hasJsonUnwrappedAnnotation(JsonUnwrappedDefinitionProvider.java:78)
Caused by: java.lang.ClassNotFoundException: com.github.victools.jsonschema.generator.AnnotationHelper
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:526)
	... 59 more
```
这个错误是由于缺少 com.github.victools.jsonschema.generator.AnnotationHelper 类导致的。这个问题通常发生在 Spring AI 的工具调用（Function Call）功能中，因为它依赖 JSON Schema 生成器来生成工具的参数模式。
* 解决方案
```xml
<dependency>
    <groupId>com.github.victools</groupId>
    <artifactId>jsonschema-generator</artifactId>
    <version>4.32.0</version>
</dependency>

<dependency>
    <groupId>com.github.victools</groupId>
    <artifactId>jsonschema-module-jackson</artifactId>
    <version>4.32.0</version>
</dependency>
```

文本理解,没有调用function call: 经过测试, 问题不在代码, 而是傻逼qwen-flash很蠢, 应该使用qwen-plus

## 暂时未再次复现bug
messageId主键插入异常: 重复主键Id

Android 端存在问题: 后端发送EOF表示发送完成，并不代表前端播放完成。

Android端回显存在问题：转换成功之后将消息发给前端的消息是上一条内容，内容是错误的

检查聊天记录顺序, 聊天记录顺序可能存在问题 (Android端的排序问题)

Agent设定存在问题，Agent会错误的把系统级别设定认为是用户的对话内容
(!!)长时间未连接之后再次连接会发生Connect Reset，这个唤醒判断时间太长了，高达19s，需要学习SpringAI ChatClient的源码，将其超时时间改为3~5s，然后快速重试。: (通过设置timeout并捕获重新调用解决)
```java
        Flux<String> responseFlux = chatClient.prompt()
                .user(sentence)
                .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, chatContextManager.agentId))
                .stream()
                .content()
                // 3500ms未响应则判定超时，进行重连尝试
                .timeout(Duration.ofMillis(ModelConstant.LLM_CONNECT_TIMEOUT_MILLIS));
```

## 待定

全流式碎片发送导致文本可视性差, 改为使用整句发送接收

(*)minio存储文件异常 -> 完成minio文件存储以及资源反向代理 -> url展示

(*)Android View展示: CallDialog数据不全

tts的文本长度限制未(0, 600]: 
```text
Exception in thread "AudioChat-3" com.alibaba.dashscope.exception.ApiException: 
{"statusCode":400,"message":"<400> InternalError.Algo.InvalidParameter: 
Range of input length should be [0, 600]","code":"InvalidParameter","isJson":true,
"requestId":"c3779a6d-0936-4ba7-9710-a1aa1007d7d2"}; 
status body:{"statusCode":400,"message":"<400> InternalError.Algo.InvalidParameter: Range of input length should be [0, 600]","code":"InvalidParameter",
"isJson":true,"requestId":"c3779a6d-0936-4ba7-9710-a1aa1007d7d2"}
```





# 开发心得

记录Bug出现, 思考Bug出现的成因. 避免再次犯同样的错误

## 容易出现Bug的地方
1. 数据结构转换拷贝 -> Mapper, Service, Controller层数据传输类型转换, 容易出现数据未赋值; 前端接收从response转为vo, ao容易出现未赋值
   * 解决方案：从业务确定Vo和Ao，然后反向定义Do和Mapper，最后编写Converter。
2. 状态变化: 多事件更新一个状态导致状态更新混乱, 多线程并发更新状态出现异步错误:
   * 用代码内部mq对状态上锁更新
   * 同一流程的的多个状态值整合为一个具有多种状态的值; 其余并发状态值才多使用
   * 用draw.io绘制流程图\状态图
3. 代码复用：代码复用就一定会引入状态值，状态值的维护容易出错。
   * 原先函数逻辑尽量不变，剥离并使用新的函数进行代理
4. 多线程并发问题
   * 并行的时候也会出现各种前后工作流和并行关系，都是通过状态值进行控制。如果不绘制并发工作图，状态值很容易出错。